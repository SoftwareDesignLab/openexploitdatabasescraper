from open_exploit_database_scraping.exploit.models import Exploit
from django.core.exceptions import ObjectDoesNotExist, MultipleObjectsReturned
from django.core.management.base import BaseCommand
from scrapy.crawler import CrawlerProcess
import requests
import re


class Command(BaseCommand):
    help = "Will go through existing CXSecurity and ExploitDB exploit entries and generate the source url for each entry."

    def add_arguments(self, parser):
        # Add run flags for the two sources that can have their source urls generated from existing entries.
        parser.add_argument("-e", "--exploitdb", action="store_true", help="A no-run flag for ExploitDB source URL generating.")
        parser.add_argument("-c", "--cxsecurity", action="store_true", help="A no-run flag for CXSecurity source URL generating.")
        parser.add_argument("-g", "--github", action="store_true", help="A no-run flag for GitHub source URL generating.")

    def handle(self, *args, **kwargs):
        n_updated = 0
        if kwargs["exploitdb"] is not True:
            exp_updated = 0
            # ExploitDB's base URL for exploits.
            # NOTE: While the source URL points to an exploit from ExploitDB's website, 
            #       the exploit was actually scraped for ExploitDB's gitlab repo.
            base_url = "https://www.exploit-db.com/exploits/"
            for exploit in Exploit.objects.filter(source="ExploitDB"):
                if exploit.source_url is None:
                    # Grab the exploit's id (name).
                    exploit_id = exploit.name
                    # We just want the id part of the name, not the file extension.
                    exploit_id = exploit_id.split('.')[0] # "example.txt" -> ["example", "txt"]
                    # Assemble source url and save it to the model.
                    exploit.source_url = base_url + exploit_id
                    exploit.save()
                    n_updated += 1
                    exp_updated += 1
                    if exp_updated % 1000 == 0:
                        print(f"\n[INFO]{exp_updated} ExploitDB entries updated.")
                        
        if kwargs["cxsecurity"] is not True:
            cx_updated = 0
            # CXsecurity's base url for an exploit's details.
            base_url = "https://cxsecurity.com/issue/"
            for exploit in Exploit.objects.filter(source="CXSecurity"):
                if exploit.source_url is None:
                    # Check if this exploit has an example file (required to build source URL):
                    if exploit.example_file is None:
                        # Skip exploit, we cannot build source URL.
                        continue
                    # Grab the exploit's id (name).
                    exploit_id = exploit.example_file.name
                    # We just want the id part of the name, not the file extension.
                    exploit_id = exploit_id.split('.')[0] # "example.txt" -> ["example", "txt"]
                    # Assemble source url and save it to the model.
                    exploit.source_url = base_url + exploit_id
                    exploit.save()
                    n_updated += 1
                    cx_updated += 1
                    if cx_updated % 1000 == 0:
                        print(f"\n[INFO]{cx_updated} CXSecurity entries updated.")


        if kwargs["github"] is not True:
            gh_updated = 0
            response = requests.get("https://raw.githubusercontent.com/nomi-sec/PoC-in-GitHub/master/README.md")
            # Iterate through the readme containing exploit repos info.
            for line in response.text.split('\n'):
                # parse for CVE
                if line.startswith('###'):
                    cve = re.search('CVE-\d*-\d*', line).group()
                # parse for urls
                if line.startswith('-'):
                    # Nab the repo link and author.
                    link = re.search('\(([^)]+)\)', line).group(1)
                    author = link.split('/')[3]
                    # Reconstruct the exploit name so that we may find it in our database.
                    name = cve + '_' + author
                    try:
                        # If we have an exploit that matches and it doesn't have a source_url, update it.
                        exploit = Exploit.objects.get(source="GitHub", name=name, source_url=None)
                        exploit.source_url = link
                        # Save the change
                        exploit.save()
                        n_updated += 1
                        gh_updated += 1
                        if gh_updated % 1000 == 0:
                            print(f"\n[INFO]{gh_updated} Github entries updated.")
                    except ObjectDoesNotExist:
                        # Otherwise, move on.
                        continue
                    except MultipleObjectsReturned:
                        # If we have multiple, select them an handle them here.
                        exploits = Exploit.objects.filter(source="GitHub", name=name, source_url=None)
                        exploits.update(source_url=link)
                        n_updated += len(exploits)
                        gh_updated += len(exploits)

        if(kwargs["exploitdb"] and kwargs["cxsecurity"] and kwargs["github"]):
            print("\n[WARNING] All sources were flagged for no run.")

        print(f"\n[INFO] {n_updated} exploits were updated with a source URL.")